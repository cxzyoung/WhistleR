% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/AllGenerics.R, R/RegionPropertiesFunctions.R
\docType{methods}
\name{extractRegionProperty}
\alias{extractRegionProperty}
\alias{extractRegionOverlap}
\alias{extractRegionLength}
\alias{extractRegionLetterFrequency}
\alias{extractRegionScores}
\alias{extractRegionYCount}
\alias{extractRegionNearestDistToY}
\alias{extractRegionRelativePosition}
\alias{extractDistToRegion5end}
\alias{extractDistToRegion3end}
\alias{extractRegionProperty,GRanges-method}
\alias{extractRegionOverlap,GRanges-method}
\alias{extractRegionLength,GRanges-method}
\alias{extractRegionLetterFrequency,GRanges-method}
\alias{extractRegionScores,GRanges-method}
\alias{extractRegionYCount,GRanges-method}
\alias{extractRegionNearestDistToY,GRanges-method}
\alias{extractRegionRelativePosition,GRanges-method}
\alias{extractDistToRegion5end,GRanges-method}
\alias{extractDistToRegion3end,GRanges-method}
\title{Method extractRegionProperty}
\usage{
extractRegionProperty(
  x,
  region,
  property,
  ambiguityMethod = c("auto", "mean", "sum", "min", "max"),
  maxgap = 0L,
  minoverlap = 0L,
  type = c("any", "start", "end", "within", "equal"),
  nomapValue = c("NA", "0", "FALSE", "nearest"),
  ignore.strand = FALSE
)

extractRegionOverlap(
  x,
  region = NULL,
  ambiguityMethod = c("auto", "mean", "sum", "min", "max"),
  maxgap = -1L,
  minoverlap = 0L,
  type = c("any", "start", "end", "within", "equal"),
  ignore.strand = FALSE,
  output.logical = TRUE
)

extractRegionLength(
  x,
  region = NULL,
  ambiguityMethod = c("mean", "sum", "min", "max"),
  maxgap = -1L,
  minoverlap = 0L,
  type = c("any", "start", "end", "within", "equal"),
  nomapValue = c("NA", "0", "nearest"),
  ignore.strand = FALSE
)

extractRegionLetterFrequency(
  x,
  sequence,
  region = NULL,
  letters = "GC",
  as.prob = TRUE,
  ambiguityMethod = c("mean", "sum", "min", "max"),
  maxgap = -1L,
  minoverlap = 0L,
  type = c("any", "start", "end", "within", "equal"),
  nomapValue = c("NA", "0", "nearest"),
  ignore.strand = FALSE,
  efficient = TRUE,
  ...
)

extractRegionScores(
  x,
  gscores,
  region = NULL,
  ambiguityMethod = c("mean", "sum", "min", "max"),
  maxgap = -1L,
  minoverlap = 0L,
  type = c("any", "start", "end", "within", "equal"),
  nomapValue = c("NA", "0", "nearest"),
  missingScores = c("zero", "mean", "none"),
  ignore.strand = FALSE,
  efficient = TRUE,
  ...
)

extractRegionYCount(
  x,
  y,
  region = NULL,
  normalize = FALSE,
  ambiguityMethod = c("mean", "sum", "min", "max"),
  maxgap = -1L,
  minoverlap = 0L,
  type = c("any", "start", "end", "within", "equal"),
  nomapValue = c("NA", "0", "nearest"),
  ignore.strand = FALSE,
  efficient = TRUE
)

extractRegionNearestDistToY(
  x,
  y,
  region = NULL,
  ambiguityMethod = c("mean", "sum", "min", "max"),
  maxgap = -1L,
  minoverlap = 0L,
  type = c("any", "start", "end", "within", "equal"),
  nomapValue = c("NA", "0", "nearest"),
  maxDist = 3e+06,
  ignore.strand = FALSE
)

extractRegionRelativePosition(
  x,
  region = NULL,
  ambiguityMethod = c("mean", "sum", "min", "max"),
  nomapValue = c("NA", "0"),
  ignore.strand = FALSE
)

extractDistToRegion5end(
  x,
  region = NULL,
  ignore.strand = FALSE,
  ambiguityMethod = c("mean", "sum", "min", "max"),
  maxgap = -1L,
  minoverlap = 0L,
  type = c("any", "start", "end", "within", "equal"),
  nomapValue = c("NA", "0", "nearest")
)

extractDistToRegion3end(
  x,
  region = NULL,
  ignore.strand = FALSE,
  ambiguityMethod = c("mean", "sum", "min", "max"),
  maxgap = -1L,
  minoverlap = 0L,
  type = c("any", "start", "end", "within", "equal"),
  nomapValue = c("NA", "0", "nearest")
)

\S4method{extractRegionProperty}{GRanges}(
  x,
  region,
  property,
  ambiguityMethod = c("auto", "mean", "sum", "min", "max"),
  maxgap = 0L,
  minoverlap = 0L,
  type = c("any", "start", "end", "within", "equal"),
  nomapValue = c("NA", "0", "FALSE", "nearest"),
  ignore.strand = FALSE
)

\S4method{extractRegionOverlap}{GRanges}(
  x,
  region = NULL,
  ambiguityMethod = c("auto", "mean", "sum", "min", "max"),
  maxgap = -1L,
  minoverlap = 0L,
  type = c("any", "start", "end", "within", "equal"),
  ignore.strand = FALSE,
  output.logical = TRUE
)

\S4method{extractRegionLength}{GRanges}(
  x,
  region = NULL,
  ambiguityMethod = c("mean", "sum", "min", "max"),
  maxgap = -1L,
  minoverlap = 0L,
  type = c("any", "start", "end", "within", "equal"),
  nomapValue = c("NA", "0", "nearest"),
  ignore.strand = FALSE
)

\S4method{extractRegionLetterFrequency}{GRanges}(
  x,
  sequence,
  region = NULL,
  letters = "GC",
  as.prob = TRUE,
  ambiguityMethod = c("mean", "sum", "min", "max"),
  maxgap = -1L,
  minoverlap = 0L,
  type = c("any", "start", "end", "within", "equal"),
  nomapValue = c("NA", "0", "nearest"),
  ignore.strand = FALSE,
  efficient = TRUE,
  ...
)

\S4method{extractRegionScores}{GRanges}(
  x,
  gscores,
  region = NULL,
  ambiguityMethod = c("mean", "sum", "min", "max"),
  maxgap = -1L,
  minoverlap = 0L,
  type = c("any", "start", "end", "within", "equal"),
  nomapValue = c("NA", "0", "nearest"),
  missingScores = c("zero", "mean", "none"),
  ignore.strand = FALSE,
  efficient = TRUE,
  ...
)

\S4method{extractRegionYCount}{GRanges}(
  x,
  y,
  region = NULL,
  normalize = FALSE,
  ambiguityMethod = c("mean", "sum", "min", "max"),
  maxgap = -1L,
  minoverlap = 0L,
  type = c("any", "start", "end", "within", "equal"),
  nomapValue = c("NA", "0", "nearest"),
  ignore.strand = FALSE,
  efficient = TRUE
)

\S4method{extractRegionNearestDistToY}{GRanges}(
  x,
  y,
  region = NULL,
  ambiguityMethod = c("mean", "sum", "min", "max"),
  maxgap = -1L,
  minoverlap = 0L,
  type = c("any", "start", "end", "within", "equal"),
  nomapValue = c("NA", "0", "nearest"),
  maxDist = 3e+06,
  ignore.strand = FALSE
)

\S4method{extractRegionRelativePosition}{GRanges}(
  x,
  region = NULL,
  ambiguityMethod = c("mean", "sum", "min", "max"),
  nomapValue = c("NA", "0"),
  ignore.strand = FALSE
)

\S4method{extractDistToRegion5end}{GRanges}(
  x,
  region = NULL,
  ignore.strand = FALSE,
  ambiguityMethod = c("mean", "sum", "min", "max"),
  maxgap = -1L,
  minoverlap = 0L,
  type = c("any", "start", "end", "within", "equal"),
  nomapValue = c("NA", "0", "nearest")
)

\S4method{extractDistToRegion3end}{GRanges}(
  x,
  region = NULL,
  ignore.strand = FALSE,
  ambiguityMethod = c("mean", "sum", "min", "max"),
  maxgap = -1L,
  minoverlap = 0L,
  type = c("any", "start", "end", "within", "equal"),
  nomapValue = c("NA", "0", "nearest")
)
}
\arguments{
\item{x}{A \link{GRanges} object for the query.}

\item{region}{A \link{GRanges} or \link{GRangesList} object for the subject. 
If not provided (\code{region=NULL}), the returned properties will be calculated directly from \code{x}.}

\item{property}{A vector specifying the properties/attributes of the \code{region}.}

\item{ambiguityMethod}{By default, for \code{logical} \code{property} input, if x overlaps multiple regions, 
as long as any of the properties is TRUE, the returned value will be TRUE. 
For other types of \code{property} input, the returned property will be the average of the properties over multiple overlapped regions.
If \code{ambiguityMethod} is \code{"mean"}, \code{"sum"}, \code{"min"}, or \code{"max"},
then the mean, sum, minimum, and maximum values of the >1 mapping will be returned in the output value.}

\item{maxgap, minoverlap, type}{See \code{?\link{findOverlaps}} in the \bold{IRanges} package for a description of these arguments.}

\item{nomapValue}{When \code{nomapValue} is \code{"NA"}, \code{"0"}, or \code{"FALSE"}, 
the \code{x} that do not match the \code{region} will return \code{NA}, \code{0}, and \code{FALSE} respectively.
If \code{nomapValue} is \code{"nearest"}, the not matched \code{x} will be set to be the property value on its nearest \code{region}.}

\item{ignore.strand}{When set to \code{TRUE}, the strand information is ignored in the overlap calculations.}

\item{output.logical}{If \code{TRUE} then the returned value is \code{logical}, otherwise \code{numeric}.}

\item{sequence}{A \link{BSgenome} or \link{XStringSet} object. 
See the \link{available.genomes} function for how to install a genome.}

\item{as.prob, letters}{See \code{?\link{letterFrequency}} in the \bold{Biostrings} package for a description of these arguments.}

\item{efficient}{\code{TRUE} if only internally extract the properties on \code{regions} overlap with \code{x}, 
the option makes the computation more efficient if the number of gnomic regions is much larger than the query.}

\item{...}{Additional arguments, it passes to \link{letterFrequency} in method \code{extractRegionLetterFrequency}, and it passes to \link{score} in method \code{extractRegionScores}.}

\item{gscores}{A \link{GScores} object. 
See the vignette for more details: \code{vignette("GenomicScores", package = "GenomicScores")}.}

\item{missingScores}{Specifying the imputation methods on missing scores in \code{extractRegionScores}, 
default is returning zero for unknown gscores under the region.}

\item{y}{A \link{GRanges} or \link{GRangesList} object for the clustering annotation.}

\item{normalize}{If \code{TRUE}, then returned count in \code{extractRegionYCount} will be divided by the length of the region.
The normalized count can be understood as the density of the annotation on the area.}

\item{maxDist}{A value of the maximum nucleotide distance returned in \code{extractRegionNearestDistToY}, default: \code{3e+06}.}
}
\value{
A logical or a numeric vector with the same length as \code{x}.

For \code{extractRegionProperty}, the vector type depends on the type of \code{property}.

For \code{extractRegionOverlap} either logical when \code{output.logical = TRUE} or a numeric otherwise.
}
\description{
Methods for annotating the query \link{GenomicRanges} with various properties on the subject regions, 
and the subject regions could be either \link{GenomicRanges} or \link{GRangesList} objects.

The \code{extractRegionProperty} function extract the annotations on each query ranges from the properties of their overlapping/nearest subject regions.

Other functions are specific implementations of \code{extractRegionProperty}, 
and their purpose is to summarize the genomic features frequently involved in functional genomics analysis.

\code{extractRegionOverlap} computes the overlapping of each query ranges with the subject regions. 
Likewise, the \code{extractRegionLength}, \code{extractRegionLetterFrequency}, and \code{extractRegionScores} functions 
compute the Lengths, Sequence Contents, and \link{GenomicScores} of the overlapped subjects.

\code{extractRegionYCount} and \code{extractRegionNearestDistToY} quantify the density/distance of an annotation (Y) 
over the subject regions, the resulting properties can capture the clustering effect between the subject region and the annotation object.

The functions \code{extractDistToRegion5end} & \code{extractDistToRegion3end} retrieve the distance between the query and ends of the subject, and
the \code{extractRegionRelativePosition} function extract the relative position of the query in the matched regions. 
Specifically, the relative position is calculated by dividing the distance of the query to the 5'-end of the region by the length of the region.
}
\details{
Please check the documentation of \link{extractRegionProperty} for details.

For specific extractor functions, when only x is provided with \code{region = NULL}, 
the functions directly use the query ranges to calculate the corresponding properties. 

In case the region ranges are provided, 
the extractor functions first find the index where x overlaps with the region and then matches the property of the region to the query GRanges according to the overlapping index.

For \code{nomapValue = "nearest"}, 
when ranges in \code{x} do not overlap with ranges in \code{regions}, the extractor functions will additionally match the unmapped x with its nearest region. 

For \code{extractRegionNearestDistToY}, if ranges in \code{y} overlap the ranges in \code{x}, 
the overlapped ranges in \code{y} are skipped and the ranges precede or follow \code{x} are used to calculate the distances.
}
\examples{
## ---------------------------------------------------------------------
## BASIC EXAMPLES
## ---------------------------------------------------------------------
library(GenomicRanges)

## Build the query GRanges object:
x_gr <- GRanges(rep(c("chr1", "chr2"), c(5, 15)),
                IRanges(c(sample(11874:12127, 5), sample(38814:41527,15)), width=100),
                strand=Rle(c("+", "-"), c(5, 15)))
x_gr    

## The region GRanges or GRangesList object:
exons_gr <- GRanges(c("chr1","chr2","chr2"),
                    IRanges(start=c(11874,38814,45440),end=c(12227,41627,46588)),
                     strand=c("+","-","-"))
genes_grl <- GRangesList(gene1=exons_gr[1],gene2=exons_gr[c(2,3)])        

## Extract lengths of the query:
extractRegionLength(x_gr)

## Extract length of the exon overlapped by the query:
extractRegionLength(x_gr, exons_gr)

## Extract exonic length of the genes overlapped by the query:
extractRegionLength(x_gr, genes_grl)

## Exract self defined property on exons overlapped by the query:
exons_property <- c(1,6,8)
extractRegionProperty(x_gr, exons_gr, exons_property)

## ---------------------------------------------------------------------
## MORE FEATURE EXTRACTORS
## ---------------------------------------------------------------------

## Quantifying clustering effect with annotation y:

## Self clustering
extractRegionYCount(x_gr, x_gr)

## Self clustering on overlapping exons/genes
extractRegionYCount(x_gr, x_gr, exons_gr)
extractRegionYCount(x_gr, x_gr, genes_grl)

## Clustering with another annotation:
y_gr <- GRanges(rep(c("chr1", "chr2"), c(50, 50)),
                IRanges(c(sample(11874:12127, 50), 
                          sample(38814:41527,50)), width=1),
                strand=Rle(c("+", "-"), c(50, 50)))

extractRegionYCount(x_gr, y_gr)
extractRegionYCount(x_gr, y_gr, exons_gr)
extractRegionYCount(x_gr, y_gr, genes_grl)
extractRegionNearestDistToY(x_gr, y_gr)

## Relative position on exons/genes:
extractRegionRelativePosition(x_gr, exons_gr)
extractRegionRelativePosition(x_gr, genes_grl)

## Distance to 5'end/3'end of exons/genes:
extractDistToRegion5end(x_gr, exons_gr)
extractDistToRegion5end(x_gr, genes_grl)
extractDistToRegion3end(x_gr, exons_gr)
extractDistToRegion3end(x_gr, genes_grl)

## Extract features that depends on sequence/annotation packages:

\dontrun{

library(BSgenome.Hsapiens.UCSC.hg19)
bsgenome <- BSgenome.Hsapiens.UCSC.hg19

## GC content of the query:
extractRegionLetterFrequency(x_gr, bsgenome, letters="GC")

## GC contents of exons/genes containing the query:
extractRegionLetterFrequency(x_gr, bsgenome, exons_gr, letters="GC")
extractRegionLetterFrequency(x_gr, bsgenome, genes_grl, letters="GC")

library(phastCons100way.UCSC.hg19)
gscores <- phastCons100way.UCSC.hg19

## PhastCons scores of the query:
extractRegionScores(x_gr, gscores)

## PhastCons scores of exons/genes containing the query:
extractRegionScores(x_gr, gscores, exons_gr)
extractRegionScores(x_gr, gscores, genes_grl)

}

## ---------------------------------------------------------------------
## VISUALIZE FEATURE IN PREDICTION MODEL
## ---------------------------------------------------------------------

## Load the GRanges of the m6A miCLIP dataset prepared for the classification model:
GSE63753_abcam <- readRDS(system.file("extdata", "GSE63753_abcam.rds", package = "WhistleR"))

## The metadata column of the GRanges is a 0/1 vector, 1 for the positive m6A site, 0 is the negative DRACH:
GSE63753_abcam
table(GSE63753_abcam$target)

## Extract exon length overlapped by the DRACH sites:
library(TxDb.Hsapiens.UCSC.hg19.knownGene)

GSE63753_abcam$exon_length <- extractRegionLength(GSE63753_abcam, exons(TxDb.Hsapiens.UCSC.hg19.knownGene))

## Plot the logistic regression fit with cubic splines:
library(ggplot2)

ggplot(na.omit(as.data.frame(mcols(GSE63753_abcam))), aes(log(exon_length), target)) +
  geom_smooth(formula = y ~ splines::ns(x, 3), method = "glm", method.args = list(family = "binomial")) + 
  geom_hline(yintercept = 0.5, linetype = 3) + 
  scale_x_continuous(limits = c(4,9)) +
  scale_y_continuous(breaks = c(0, 0.25, 0.5, 0.75, 1)) +
  theme_classic() + labs(x = "log(length of exon)", y = "prob of m6A = 1", title = "LR fit with cubic splines")

}
\seealso{
\itemize{
\item{}{The \link{genomeDerivedFeatures} function for the extraction of genome-derived features.}
\item{}{The \link{sequenceDerivedFeatures} function for the extraction of sequence-derived features.}
\item{}{The \link{topologyOnTranscripts} function for generating the topology of annotations on transcripts of genes.}
}
}
\author{
Zhen Wei
}
